import os
import gc
import bpy
import sys
import uuid
import time
import math
from math import radians, degrees, asin, cos
import struct
import tempfile
import traceback
import mathutils

import xml.etree.ElementTree as ET

from .mod_settings import *

from . import meshutils

if 1 == 1:

    props = {}

    props["constraint_group_base"] = "Sim"
    props["constraint_theme_base"] = "THEME08"


def get_onigiri_version():
    for mod_name in bpy.context.preferences.addons.keys():
        mod = sys.modules[mod_name]
        name = mod.bl_info.get("name")
        if name == "Onigiri":
            version = mod.bl_info.get("version", (-1, -1, -1))
            return version
    print(
        "utils::get_onigiri_version reports: Something went wrong when trying to get the Onigiri version"
    )
    return False


def get_safe_name(names=None, max=100, report=False):
    fail = 0
    for i in range(max):
        name = get_temp_name()
        if name not in names:
            return name
        if report == True:
            print(
                "utils::get_safe_name reports : collision ",
                name,
                " (",
                fail,
                ")",
                sep="",
            )
    print(
        "utils::get_safe_name reports : fall through, apparently there were",
        max,
        "collisions",
    )
    return False


def get_unique_name():

    idn = str(uuid.uuid4())
    name = idn.replace("-", "")
    idt = str(time.time())
    time_now = idt.replace(".", "_")
    unique_name = name + "_" + time_now
    return unique_name


def get_unique_name_short():

    found = "yes"
    break_point = 0
    while found == "yes":
        unique_name = str(uuid.uuid4())
        break_point += 1
        if unique_name not in bpy.data.objects:
            name_search = "not found"
            break
        if break_point == 100:
            print(
                "get_unique_name_short reports: 100 names were searched and found, this probably can't happen"
            )
            popup(
                "Houston we have a problem!  Name collision, check console",
                "Name Collision 100",
                "ERROR",
            )
            break

    return unique_name.split("-", 1)[0]


def get_temp_name():
    unique_name = str(uuid.uuid4())
    return unique_name.split("-", 1)[0]


def popup(message="", title="Message Box", icon="INFO"):

    lines = message.splitlines()

    def draw(self, context):
        for l in lines:
            self.layout.label(text=l)

    bpy.context.window_manager.popup_menu(draw, title=title, icon=icon)
    return


def format_ctm(container=None):
    if container == None:
        print("format_ctm reports: nothing to do")
        return False

    formatted_text = "# Character Template Map auto-generated by Onigiri\n"
    formatted_text += "template_map = {\n"
    for sbone in container:
        ((tarm, tbone),) = container[sbone].items()
        formatted_text += "    " + '"' + sbone + '": ' + "{" + "\n"
        formatted_text += (
            "        " + '"' + tarm + '": ' + '"' + tbone + '",' + "\n" + "        },\n"
        )
    formatted_text += "    }\n"
    return formatted_text


def format_ccm(container=None):

    if container == None:
        print("format_ccm reports: nothing to do")

    obj = bpy.data.objects

    rename = container.get("rename")
    reskin = container.get("reskin")
    pose = container.get("pose")
    if rename == None or reskin == None:
        print("format_ccm reports: container is defective")
        return False

    formatted_text = "# Character Converter Map auto-generated by Onigiri\n"
    formatted_text = "rename = {\n"
    for tbone in rename:
        formatted_text += (
            "    " + '"' + tbone + '": ' + '"' + rename[tbone] + '"' + ",\n"
        )
    formatted_text += "    }\n"
    formatted_text += "reskin = {\n"
    for tbone in reskin:
        formatted_text += "    " + '"' + tbone + '": [' + "\n"
        for ghost_bone in reskin[tbone]:
            formatted_text += "        " + '"' + ghost_bone + '"' + ",\n"
        formatted_text += "        ],\n"
    formatted_text += "    }\n"
    if pose != None:

        formatted_text += "pose = {\n"
        for tbone in pose:
            formatted_text += "    " + '"' + tbone + '": [\n'
            for matrix in pose[tbone]:
                formatted_text += "        " + str(matrix) + ",\n"
            formatted_text += "        ],\n"
        formatted_text += "    }\n"

    return formatted_text


def flag_reloader():

    script_dir = os.path.dirname(os.path.abspath(__file__))

    print("-reload was triggered-")
    temp_path = tempfile.gettempdir()
    print(".path to temporary directory:", temp_path)
    source_file = "__init__.py"
    print(".storing backup of", source_file)
    source_path = script_dir + "/" + source_file
    target_path = temp_path + "/onigiri_reloader" + ".py"

    try:
        src = open(source_path, "r", encoding="UTF8")
    except Exception as e:
        txt = traceback.format_exc()
        print(txt)
        print("There was an error opening the source file for reading:", source_path)
        popup("Error opening source", "Error", "ERROR")
        return {"FINISHED"}

    src_buf = src.read()
    src.close()

    try:
        dst = open(target_path, "w", encoding="UTF8")
        dst.write(src_buf)
        dst.close()
    except Exception as e:
        txt = traceback.format_exc()
        print(txt)
        print("There was an error opening the target file for writing:", target_path)
        popup("Error writing target", "Error", "ERROR")
        return {"FINISHED"}

    try:
        dst = open(target_path, "r", encoding="UTF8")
        dst_buf = dst.read()
        dst.close()
    except Exception as e:
        txt = traceback.format_exc()
        print(txt)
        print(
            "There was an error opening the target file in read mode for comparing:",
            target_path,
        )
        popup("Error reading target for comparison", "Error", "ERROR")
        return {"FINISHED"}

    if dst_buf != src_buf:
        print(
            "The destination and source do not match after a comparison, their file/paths are below"
        )
        print("source:", source_path)
        print("target:", target_path)
        return {"FINISHED"}

    print("write back is processing...")
    try:
        src = open(source_path, "w", encoding="UTF8")
        src.write(src_buf)
        src.close()
    except Exception as e:
        txt = traceback.format_exc()
        print(txt)
        print("There was an error with the write-back process:", source_path)
        popup("Fatal Error, check backup data", "Error", "ERROR")
        return {"FINISHED"}

    print("-reload ends successfully-")

    return True


def run_script(script=None):

    script_dir = os.path.dirname(os.path.abspath(__file__))
    path = script_dir + presets_path

    print("would have run blender from:", blender, "using script:", script)
    return True


def add_constraint(
    source="",
    sbone="",
    target="",
    tbone="",
    type="COPY_TRANSFORMS",
    influence=1,
    target_space="WORLD",
    owner_space="WORLD",
    invert=True,
    owner="BONE",
):

    if bpy.data.objects[source].type == "ARMATURE":
        bc = bpy.data.objects[source].pose.bones[sbone].constraints
    else:
        bpy.ops.object.mode_set(mode="OBJECT")
        bc = bpy.data.objects[source].constraints

    if type == "CHILD_OF":
        bc.new("CHILD_OF")
        bc["Child Of"].target = bpy.data.objects[target]
        bc["Child Of"].subtarget = tbone
        bc["Child Of"].influence = influence
        bc["Child Of"].name = "ONI Child Of"
        if invert == True:
            context_py = bpy.context.copy()
            context_py["constraint"] = bc.active
            set_inverse(context_py, "ONI Child Of")

        return
    elif type == "COPY_LOCATION":
        bc.new("COPY_LOCATION")
        bc["Copy Location"].target = bpy.data.objects[target]
        bc["Copy Location"].subtarget = tbone
        bc["Copy Location"].target_space = target_space
        bc["Copy Location"].owner_space = owner_space
        bc["Copy Location"].influence = influence
        bc["Copy Location"].name = "ONI Copy Loc"
        return
    elif type == "COPY_ROTATION":
        bc.new("COPY_ROTATION")
        bc["Copy Rotation"].target = bpy.data.objects[target]
        bc["Copy Rotation"].subtarget = tbone
        bc["Copy Rotation"].target_space = target_space
        bc["Copy Rotation"].owner_space = owner_space
        bc["Copy Rotation"].influence = influence
        bc["Copy Rotation"].name = "ONI Copy Rot"
        return
    elif type == "COPY_SCALE":
        bc.new("COPY_SCALE")
        bc["Copy Scale"].target = bpy.data.objects[target]
        bc["Copy Scale"].subtarget = tbone
        bc["Copy Scale"].target_space = target_space
        bc["Copy Scale"].owner_space = owner_space
        bc["Copy Scale"].influence = influence
        bc["Copy Scale"].name = "ONI Copy Scale"
        return
    elif type == "COPY_TRANSFORMS":
        bc.new("COPY_TRANSFORMS")
        bc["Copy Transforms"].target = bpy.data.objects[target]
        bc["Copy Transforms"].subtarget = tbone
        bc["Copy Transforms"].target_space = target_space
        bc["Copy Transforms"].owner_space = owner_space
        bc["Copy Transforms"].influence = influence
        bc["Copy Transforms"].name = "ONI Copy TRS"
        return
    else:
        print("add_constraint called with unknown type", type)
    return


def sl_orientation(objects=[]):
    obj = bpy.data.objects
    rotated = {}

    if 1 == 0:
        try:
            print("moo")
        except Exception as e:
            txt = traceback.format_exc()
            print(txt)

    for o in bpy.context.selected_objects:
        o.select_set(False)

    layer_settings = {}

    for name in objects:
        layer_settings[name] = {}
        layer_settings[name]["hide_set"] = obj[name].hide_get()
        layer_settings[name]["hide_select"] = obj[name].hide_select
        layer_settings[name]["hide_viewport"] = obj[name].hide_select

        obj[name].hide_set(False)
        obj[name].hide_select = False
        obj[name].hide_viewport = False
        obj[name].select_set(True)

    bpy.context.view_layer.objects.active = obj[objects[0]]
    bpy.ops.object.duplicate()
    mrig = bpy.context.active_object.name

    for name in objects:
        hide_set = layer_settings[name]["hide_set"]
        obj[name].hide_set(hide_set)
        obj[name].hide_select = layer_settings[name]["hide_select"]
        obj[name].hide_viewport = layer_settings[name]["hide_viewport"]

    rotated["mbones"] = []
    rotated["mbones"].append(mrig)
    for o in bpy.context.selected_objects:
        if o.name == mrig:
            continue
        rotated["mbones"].append(o.name)

    bpy.ops.object.duplicate()

    vrig = bpy.context.active_object.name

    rotated["vbones"] = []
    rotated["vbones"].append(vrig)
    for o in bpy.context.selected_objects:
        if o.name == vrig:
            continue
        rotated["vbones"].append(o.name)

    for o in bpy.context.selected_objects:
        o.select_set(False)

    for name in rotated["mbones"]:

        obj[name].select_set(True)
        bpy.context.view_layer.objects.active = obj[name]
        bpy.ops.object.transform_apply(rotation=True, location=False, scale=False)

        loc, rot, scale = obj[name].matrix_world.decompose()
        smat = mathutils.Matrix()
        for i in range(3):
            smat[i][i] = scale[i]
        eu = mathutils.Euler(map(radians, (-90, 0, 0)), "XYZ")
        mat = mathutils.Matrix.Translation(loc) @ eu.to_matrix().to_4x4() @ smat
        obj[name].matrix_world = mat
        bpy.ops.object.transform_apply(rotation=True, location=False, scale=False)
        obj[name].select_set(False)

    for name in rotated["vbones"]:
        obj[name].select_set(True)
        bpy.context.view_layer.objects.active = obj[name]
        bpy.ops.object.transform_apply(rotation=True, location=False, scale=False)
        loc, rot, scale = obj[name].matrix_world.decompose()
        smat = mathutils.Matrix()
        for i in range(3):
            smat[i][i] = scale[i]
        eu = mathutils.Euler(map(radians, (0, 0, 90)), "XYZ")
        mat = mathutils.Matrix.Translation(loc) @ eu.to_matrix().to_4x4() @ smat
        obj[name].matrix_world = mat
        bpy.ops.object.transform_apply(rotation=True, location=False, scale=False)
        obj[name].select_set(False)

    for o in bpy.context.selected_objects:
        o.select_set(False)

    if 1 == 1:
        obj[mrig].select_set(True)
        bpy.context.view_layer.objects.active = obj[mrig]
        bpy.ops.object.mode_set(mode="POSE")
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode="OBJECT")
        obj[mrig].select_set(False)
        obj[vrig].select_set(True)
        bpy.context.view_layer.objects.active = obj[vrig]
        bpy.ops.object.mode_set(mode="POSE")
        bpy.ops.pose.armature_apply()
        bpy.ops.object.mode_set(mode="OBJECT")
        obj[vrig].select_set(False)

    return rotated


def anim_reader(file=""):

    f = open(file, "rb")
    content = f.read()
    f.close()

    header = {}

    header["version"] = int.from_bytes(content[:2], byteorder="little", signed=False)
    header["sub_version"] = int.from_bytes(
        content[2:4], byteorder="little", signed=False
    )
    header["base_priority"] = int.from_bytes(
        content[4:8], byteorder="little", signed=True
    )
    header["duration"] = struct.unpack("f", content[8:12])[0]

    start = 12
    stride = 0

    for c in content[start:-1]:
        stride += 1
        if c == 0:
            break

    emote_bytes = content[start : start + stride - 1]
    header["emote_name"] = emote_bytes.decode("utf-8")

    start += stride

    header["loop"] = int.from_bytes(
        content[start : start + 4], byteorder="little", signed=True
    )
    start += 4

    header["ease_in_duration"] = struct.unpack("f", content[start : start + 4])[0]
    header["ease_out_duration"] = struct.unpack("f", content[start + 4 : start + 8])[0]
    start += 8

    header["loop_in_point"] = struct.unpack("f", content[start : start + 4])[0]
    header["loop_out_point"] = struct.unpack("f", content[start + 4 : start + 8])[0]
    start += 8

    header["hand_pose"] = int.from_bytes(
        content[start : start + 4], byteorder="little", signed=False
    )
    start += 4

    header["num_joints"] = int.from_bytes(
        content[start : start + 4], byteorder="little", signed=False
    )
    start += 4

    joints = {}
    joint_count = 0
    stride = 0
    while joint_count < header["num_joints"]:
        joint_count += 1

        character_count = 0
        for c in content[start:-1]:
            character_count += 1
            if c == 0:
                break

        joint_bytes = content[start : start + character_count - 1]
        start += character_count

        joint_name = joint_bytes.decode("utf-8")
        joints[joint_name] = {}

        joints[joint_name]["joint_priority"] = int.from_bytes(
            content[start : start + 4], byteorder="little", signed=True
        )
        start += 4

        joints[joint_name]["num_rot_keys"] = int.from_bytes(
            content[start : start + 4], byteorder="little", signed=True
        )
        start += 4
        rot_count = 0
        joints[joint_name]["rot"] = {}
        while rot_count < joints[joint_name]["num_rot_keys"]:
            rot_count += 1

            joints[joint_name]["rot"][rot_count] = list()

            joints[joint_name]["rot"][rot_count].append(
                int.from_bytes(
                    content[start : start + 2], byteorder="little", signed=False
                )
            )
            start += 2
            joints[joint_name]["rot"][rot_count].append(
                int.from_bytes(
                    content[start : start + 2], byteorder="little", signed=False
                )
            )
            start += 2
            joints[joint_name]["rot"][rot_count].append(
                int.from_bytes(
                    content[start : start + 2], byteorder="little", signed=False
                )
            )
            start += 2
            joints[joint_name]["rot"][rot_count].append(
                int.from_bytes(
                    content[start : start + 2], byteorder="little", signed=False
                )
            )
            start += 2

        joints[joint_name]["num_pos_keys"] = int.from_bytes(
            content[start : start + 4], byteorder="little", signed=True
        )
        start += 4
        loc_count = 0
        joints[joint_name]["loc"] = {}
        while loc_count < joints[joint_name]["num_pos_keys"]:
            loc_count += 1
            joints[joint_name]["loc"][loc_count] = list()
            joints[joint_name]["loc"][loc_count].append(
                int.from_bytes(
                    content[start : start + 2], byteorder="little", signed=False
                )
            )
            start += 2
            joints[joint_name]["loc"][loc_count].append(
                int.from_bytes(
                    content[start : start + 2], byteorder="little", signed=False
                )
            )
            start += 2
            joints[joint_name]["loc"][loc_count].append(
                int.from_bytes(
                    content[start : start + 2], byteorder="little", signed=False
                )
            )
            start += 2
            joints[joint_name]["loc"][loc_count].append(
                int.from_bytes(
                    content[start : start + 2], byteorder="little", signed=False
                )
            )
            start += 2

    print("constraint read disabled")
    if 1 == 0:

        constraints["num_constraints"] = int.from_bytes(
            content[start : start + 4], byteorder="little", signed=True
        )
        start += 4
        constraints["con"] = {}
        con_count = 0
        while con_count < joints[joint_name]["num_constraints"]:
            con_count += 1
            constraints["con"][con_count] = {}
            constraints["con"][con_count]["chain_length"] = int.from_bytes(
                content[start : start + 1], byteorder="little", signed=False
            )
            constraints["con"][con_count]["constraint_type"] = int.from_bytes(
                content[start : start + 1], byteorder="little", signed=False
            )
            constraints["con"][con_count]["source_volume"] = content[start : start + 2]

            constraints["con"][con_count]["source_offset"] = ""
            constraints["con"][con_count]["target_volume"] = ""
            constraints["con"][con_count]["target_offset"] = ""
            constraints["con"][con_count]["target_dir"] = ""
            constraints["con"][con_count]["ease_in_start"] = 0
            constraints["con"][con_count]["ease_in_stop"] = 0
            constraints["con"][con_count]["ease_out_start"] = 0
            constraints["con"][con_count]["ease_out_stop"] = 0

    if 1 == 0:
        print("version:", header["version"])
        print("sub version:", header["sub_version"])
        print("base priority:", header["base_priority"])
        print("duration:", "{:f}".format(header["duration"]))
        print("emote name:", header["emote_name"])
        print("loop in point:", "{:f}".format(header["loop_in_point"]))
        print("loop out point:", "{:f}".format(header["loop_out_point"]))
        print("hand pose:", header["hand_pose"])
        print("num joints:", header["num_joints"])

        for j in joints:
            print("joint name:", j)
            print("joint priority:", joints[j]["joint_priority"])
            for rkey in joints[j]["rot"]:
                print("     ", joints[j]["rot"][rkey])
            for lkey in joints[j]["loc"]:
                print("     ", joints[j]["loc"][lkey])

    anim = {
        "header": header,
        "joints": joints,
    }

    return anim


def fix_quat(r):
    v = mathutils.Vector((r))
    half_angle = asin(v.magnitude)
    w = cos(half_angle)
    v = mathutils.Quaternion((w, r[0], r[1], r[2]))
    return v


def remove_empty_groups(mesh):

    def survey(meshObj):
        maxWeight = {}
        for i in meshObj.vertex_groups:
            maxWeight[i.index] = 0

        for v in meshObj.data.vertices:
            for g in v.groups:
                gn = g.group

                try:
                    w = meshObj.vertex_groups[g.group].weight(v.index)
                except:
                    pass
                if maxWeight.get(gn) is None or w > maxWeight[gn]:
                    maxWeight[gn] = w
        return maxWeight

    meshObj = bpy.data.objects[mesh]

    armObj = meshutils.get_armature(meshObj)
    if armObj == False:
        print(
            "There's no functional armature associated with the mesh",
            meshOb.name,
            "so there's no way to prune the weight groups properly.",
        )
        return False

    maxWeight = survey(meshObj)

    ka = []
    ka.extend(maxWeight.keys())
    ka.sort(key=lambda gn: -gn)

    for gn in ka:
        if maxWeight[gn] <= 0:

            name = meshObj.vertex_groups[gn].name

            if name not in armObj.data.bones:
                print("Skipping utility group:", name)
                continue
            meshObj.vertex_groups.remove(meshObj.vertex_groups[gn])


if 1 == 0:
    import re

    ob = bpy.context.active_object
    ob.update_from_editmode()
    vgroup_used = {i: False for i, k in enumerate(ob.vertex_groups)}
    vgroup_names = {i: k.name for i, k in enumerate(ob.vertex_groups)}
    for v in ob.data.vertices:
        for g in v.groups:
            if g.weight > 0.0:
                vgroup_used[g.group] = True
                vgroup_name = vgroup_names[g.group]
                armatch = re.search("((.R|.L)(.(\d){1,}){0,1})(?!.)", vgroup_name)
                if armatch != None:
                    tag = armatch.group()
                    mirror_tag = (
                        tag.replace(".R", ".L")
                        if armatch.group(2) == ".R"
                        else tag.replace(".L", ".R")
                    )
                    mirror_vgname = vgroup_name.replace(tag, mirror_tag)
                    for i, name in sorted(vgroup_names.items(), reverse=True):
                        if mirror_vgname == name:
                            vgroup_used[i] = True
                            break
    for i, used in sorted(vgroup_used.items(), reverse=True):
        if not used:
            ob.vertex_groups.remove(ob.vertex_groups[i])


def matrix_to_list(m):
    l = list(m)
    lt = list()
    for v in l:

        t = tuple([a for a in v])
        lt.append(t)
    return lt


def bind_to_matrix(l):
    M = mathutils.Matrix()
    for i in range(4):
        for j in range(4):
            M[i][j] = l[4 * j + i]
    return M


def vector_to_list(v):
    l = [a for a in v]
    return l


def record_rig():
    import bpy
    import os
    import sys
    from .presets import avatar_skeleton as skel

    rig_file = "basic_rig.py"
    rig_path = "L:/compile/onigiri/test_material/" + rig_file

    if len(bpy.context.selected_objects) != 1:
        print("select a rig")
    if bpy.context.selected_objects[0].type != "ARMATURE":
        print("this is not an armature")

    armObj = bpy.context.selected_objects[0]

    current_frame = bpy.context.scene.frame_current

    bpy.context.scene.frame_set(1)

    if armObj.data.animation_data != None:
        frame_start, frame_end = armObj.animation_data.action.frame_range
        bpy.context.scene.frame_set(start)

    def matrix_to_list(m):
        l = list(m)
        lt = list()
        for v in l:

            t = tuple([a for a in v])
            lt.append(t)
        print(lt)
        return lt

    def vector_to_list(v):
        l = [a for a in v]
        return l

    bpy.ops.object.mode_set(mode="EDIT")
    rig_data = {}
    for boneObj in armObj.data.edit_bones:
        bone = boneObj.name
        if bone not in skel.avatar_skeleton:
            continue
        rig_data[bone] = {}
        rig_data[bone]["type"] = skel.avatar_skeleton[bone]["type"]
        rig_data[bone]["matrix_edit"] = matrix_to_list(boneObj.matrix.copy())
        rig_data[bone]["head_edit"] = vector_to_list(boneObj.head.copy())
        rig_data[bone]["tail_edit"] = vector_to_list(boneObj.tail.copy())
        rig_data[bone]["roll_edit"] = boneObj.roll
        rig_data[bone]["connected"] = skel.avatar_skeleton[bone]["connected"]

    bpy.ops.object.mode_set(mode="OBJECT")

    for boneObj in armObj.pose.bones:
        bone = boneObj.name
        if bone not in skel.avatar_skeleton:
            continue
        rig_data[bone]["matrix_pose"] = matrix_to_list(boneObj.matrix.copy())

        if boneObj.parent:
            parent = boneObj.parent.name
        else:
            parent = ""
        rig_data[bone]["parent"] = parent

    if 1 == 0:
        txt = "# Do not incorporate this until you change the dictionary name to\n"
        txt += "# male_default or male_neutral, whichever rig you chose.\n"
        txt += "\n"
        txt += "rig = {\n"
        for bone in rig_data:
            txt += '    "' + bone + '": {' + "\n"
            txt += '        "type": "' + rig_data[bone]["type"] + '",' + "\n"
            txt += (
                '        "matrix_edit": "'
                + str(rig_data[bone]["matrix_edit"])
                + '",'
                + "\n"
            )
            txt += (
                '        "head_edit": "'
                + str(rig_data[bone]["head_edit"])
                + '",'
                + "\n"
            )
            txt += (
                '        "tail_edit": "'
                + str(rig_data[bone]["tail_edit"])
                + '",'
                + "\n"
            )
            txt += (
                '        "roll_edit": "'
                + str(rig_data[bone]["roll_edit"])
                + '",'
                + "\n"
            )
            txt += '        "parent": "' + rig_data[bone]["parent"] + '",' + "\n"
            txt += (
                '        "connected": "'
                + str(rig_data[bone]["connected"])
                + '",'
                + "\n"
            )
            txt += "        }\n"

        txt += "    }\n"

    txt = "rig_data = "
    txt += str(rig_data)

    f = open(rig_path, "w", encoding="UTF8")
    f.write(txt)
    f.close()
    return


def can_select(object=None):
    if object == None:
        print("can_select: Nothing to do")
        return False

    old_mode = bpy.context.mode
    if old_mode != "OBJECT":
        bpy.ops.object.mode_set(mode="OBJECT")
    else:
        old_mode = None

    obj = bpy.data.objects
    if object not in obj:
        print("can_select: object not available", object)
        return False

    selected = [o for o in bpy.context.selected_objects]
    active = bpy.context.active_object

    for o in selected:
        o.select_set(False)

    try:
        obj[object].select_set(True)
    except:
        pass

    if len(bpy.context.selected_objects) == 0:
        print(
            "The object",
            object,
            "is not accessible in the scene, not selectable or not in view.",
        )
        return False

    if old_mode != None:
        for o in selected:
            o.select_set(True)
            bpy.ops.object.mode_set(mode=old_mode)

    try:
        bpy.context.view_layer.objects.active = active
    except:
        pass

    return True


def get_obj_size(obj):
    marked = {id(obj)}
    obj_q = [obj]
    sz = 0

    while obj_q:
        sz += sum(map(sys.getsizeof, obj_q))

        all_refr = ((id(o), o) for o in gc.get_referents(*obj_q))

        new_refr = {
            o_id: o
            for o_id, o in all_refr
            if o_id not in marked and not isinstance(o, type)
        }

        obj_q = new_refr.values()
        marked.update(new_refr.keys())

    return sz


def get_average(object):

    el = len(object[0])

    for i in range(1, len(object)):
        if len(object[i]) != el:
            print(
                "utils::get_average reports: Object sizes differ so cannot be averaged"
            )

    result = list()
    v = mathutils.Vector((0, 0, 0))
    ol = len(object)
    for o in object:
        v += mathutils.Vector(o)
    result = v / ol
    return result


def percentage(percent, whole):
    return (percent * whole) / 100.0


def cleanup():
    print("running cleanup 1")
    try:
        bpy.context.scene.oni_anim.property_unset("export_sl_anim_label")
        bpy.context.scene.oni_anim.export_sl_anim_alert = False
        bpy.context.scene.oni_anim_props.property_unset("export_sl_bvh_label")
        bpy.context.scene.oni_anim_props.export_sl_bvh_alert = False

    except:
        print("utils::cleanup reports: Some things didn't clean but that's probably ok")
    return True


def update_context():
    dg = bpy.context.evaluated_depsgraph_get()
    dg.update()


def match_all(thing):
    return all(x == thing[0] for x in thing)


def get_state(report=True):

    arms = []
    mesh = []
    bones = []
    other = []

    selected = [o for o in bpy.context.selected_objects]
    active = bpy.context.active_object

    if active == None:
        if len(selected) > 0:
            activate(selected[0])
            print("No active object in the set, fixed!")

    old_mode = bpy.context.mode
    if old_mode == "POSE":
        bones = [b for b in bpy.context.selected_pose_bones]

    if old_mode == "EDIT_ARMATURE":
        old_mode = "EDIT"
        bpy.ops.object.mode_set(mode="POSE")
        bones = [b for b in bpy.context.selected_pose_bones]
        bpy.ops.object.mode_set(mode="OBJECT")

    if old_mode == "EDIT_MESH":
        old_mode = "EDIT"

    if old_mode != "OBJECT":
        bpy.ops.object.mode_set(mode="OBJECT")

    if selected:
        bpy.ops.object.mode_set(mode="OBJECT")
        for o in selected:
            o.select_set(False)
        for o in selected:
            o.select_set(True)
            bpy.context.view_layer.objects.active = o
            bpy.ops.object.mode_set(mode="OBJECT")
            o.select_set(False)
    else:
        if report == True:
            print("utils::get_state : reports - nothing selected, will process anyway")

    for o in selected:
        o.select_set(True)
    bpy.context.view_layer.objects.active = active

    for o in selected:
        if o.type == "ARMATURE":
            arms.append(o)
        elif o.type == "MESH":
            mesh.append(o)
        else:
            other.append(o)

    for o in bpy.context.selected_objects:
        o.select_set(False)

    state = {}
    state["mode"] = old_mode
    state["selected"] = selected
    state["active"] = active
    state["armatures"] = arms
    state["mesh"] = mesh
    state["other"] = other
    state["bones"] = bones

    all_objects = [o for o in selected]
    if active != None:
        all_objects.append(active)
    for o in all_objects:
        o.select_set(True)
        bpy.context.view_layer.objects.active = o
        bpy.ops.object.mode_set(mode="OBJECT")
        o.select_set(False)
    bpy.context.view_layer.objects.active = active

    return state


def set_state(state):

    old_mode = bpy.context.mode
    if old_mode != "OBJECT":
        bpy.ops.object.mode_set(mode="OBJECT")

    for o in bpy.context.selected_objects:
        o.select_set(False)
    for o in state["selected"]:
        o.select_set(True)

    active = state["active"]
    bpy.context.view_layer.objects.active = active

    mode = state["mode"]
    if mode == "POSE":
        bpy.ops.object.mode_set(mode="POSE")
        for armObj in state["armatures"]:
            for boneObj in armObj.data.bones:
                boneObj.select = False
        for boneObj in state["bones"]:
            dBone = boneObj.bone
            dBone.select = True
    elif mode == "EDIT":
        bpy.ops.object.mode_set(mode="EDIT")

        if len(state["armatures"]) > 0:
            for armObj in state["armatures"]:
                for boneObj in armObj.data.bones:
                    boneObj.select = False
            for boneObj in state["bones"]:
                dBone = boneObj.bone
                dBone.select = True
    elif mode == "PAINT_WEIGHT":

        bpy.ops.object.mode_set(mode="WEIGHT_PAINT")

        if len(state["armatures"]) > 0:
            for armObj in state["armatures"]:
                for boneObj in armObj.data.bones:
                    boneObj.select = False
            for boneObj in state["bones"]:
                dBone = boneObj.bone
                dBone.select = True

    return True


def move_to_top(object=None, modifier=None):
    if object == None or modifier == None:
        return False
    obj = bpy.data.objects
    active = bpy.context.active_object
    bpy.context.view_layer.objects.active = obj[object]
    while obj[object].modifiers[0].name != modifier:
        bpy.ops.object.modifier_move_up(modifier=modifier)
    bpy.context.view_layer.objects.active = active
    return True


def cleanup():
    print("running cleanup 2")
    for block in bpy.data.meshes:
        if block.users == 0:
            bpy.data.meshes.remove(block)

    for block in bpy.data.materials:
        if block.users == 0:
            bpy.data.materials.remove(block)

    for block in bpy.data.textures:
        if block.users == 0:
            bpy.data.textures.remove(block)

    for block in bpy.data.images:
        if block.users == 0:
            bpy.data.images.remove(block)
    print("cleanup ran")
    return True


def delete():
    selected = bpy.context.selected_objects

    if len(selected) > 0:
        bpy.context.view_layer.objects.active = selected[0]
    if 1 == 1:
        bpy.ops.object.delete()
    else:
        for o in selected:
            if o.type == "MESH":
                bpy.data.meshes.remove(bpy.data.meshes[o.name], do_unlink=True)
            elif o.type == "ARMATURE":
                bpy.data.armatures.remove(bpy.data.armatures[o.name], do_unlink=True)

            else:
                try:
                    bpy.data.objects.remove(o)
                except:
                    print(
                        "Object",
                        o.name,
                        "of type",
                        o.type,
                        "could not be removed with (object) method",
                    )

    purge_orphans()
    return True


def purge_orphans():
    try:
        old_type = bpy.context.area.type
        bpy.context.area.type = "OUTLINER"
        bpy.context.space_data.display_mode = "ORPHAN_DATA"
        bpy.ops.outliner.orphans_purge()
        bpy.context.area.type = old_type
    except Exception as e:
        print(traceback.format_exc())
        print("Something in the purge_orphans process failed, see above for details")
        return False
    return True


def activate(object, safe=False):
    if isinstance(object, str):
        obj = bpy.data.objects
        OBJ = obj[object]
    else:
        OBJ = object
    if safe == True:
        state = get_state()
        OBJ.select_set(True)
        bpy.context.view_layer.objects.active = OBJ
        return state
    bpy.context.view_layer.objects.active = OBJ
    return True


def view_mesh(armature=None, view=False, all=True):
    obj = bpy.data.objects
    armObj = obj[armature]
    children = []
    if len(armObj.children) > 0:
        children = [c for c in armObj.children]

    directors = armObj.get("oni_sim_directors")

    d = armObj.get("oni_sim_director")
    if d != None:
        if directors != None:
            directors.append(d)
        else:
            directors = [d]

    if directors != None:
        for d in directors:
            if is_valid(d):
                children.append(d)
    for c in children:
        if all == True:
            c.hide_set(view)
        else:
            if c.type == "MESH":
                c.hide_set(view)
    return True


def view_associated_mesh(armature=None, view=False, children=True, skinned=True):
    obj = bpy.data.objects
    armObj = armature
    if isinstance(armObj, str):
        armObj = obj[armature]

    targets = []

    if children == True:
        if len(armObj.children) > 0:
            targets = [c for c in armObj.children]

    if skinned == True:
        for o in obj:
            if o.type == "MESH":
                for m in o.modifiers:
                    if m.type == "ARMATURE":
                        if m.object == armObj:
                            targets.append(o)

    for o in targets:
        try:
            o.hide_set(view)
        except:
            print(o.name, "is inaccessible, skipping...")
    return True


def nuke_controllers():
    for o in bpy.data.objects:
        if o.type == "ARMATURE":
            for pBone in o.pose.bones:
                for pbC in pBone.constraints:
                    pBone.constraints.remove(pbC)
            print("Finished bone constraints")

        for C in o.constraints:
            o.constraints.remove(C)
        print("Finished object constraints")

        if 1 == 0:
            try:
                fcurves = o.animation_data.drivers
                for fc in fcurves:
                    fcurves.remove(fc)
            except:
                print("No drivers, moving on")
            print("Finished drivers")

    return True


def is_valid(object):
    obj = bpy.data.objects

    try:
        if isinstance(object, str):
            if object not in obj:
                return False
            OBJ = obj[object]
        else:
            OBJ = object
    except:
        return False
    try:
        if OBJ.name not in bpy.context.scene.objects:
            return False
        return True
    except Exception as e:
        return False

    print("utils::is_valid : fall-through")


def has_armature(object=None, report=False):

    if len(bpy.context.selected_objects) == 0 and object == None:
        if report == True:
            print("has_armature: no object and no selection")
        return False

    obj = bpy.data.objects

    if object != None:
        if isinstance(object, str):
            OBJ = obj[object]
        else:
            OBJ = object
        if OBJ.type == "ARMATURE":
            if report == True:
                print("has_armature: found", OBJ.name)

            return OBJ

        match = []
        for M in OBJ.modifiers:
            if M.type == "ARMATURE":
                match.append(M)
        if len(match) == 1:
            M = match[0]
            armObj = M.object
            if is_valid(armObj):
                if report == True:
                    print("has_armature: found from mesh modifiers", OBJ.name)

                return armObj
            else:
                if report == True:
                    print(
                        "utils::has_armature reports : The armature that the single armature modifier points to is invalid"
                    )
                return False

        txt = ""
        if len(match) > 1:
            txt = "too many armature modifiers"
        if len(match) == 0:
            txt = "no armature modifiers"
        if report == True:
            print("utils::has_armature reports :", txt)
        return False

    selected = bpy.context.selected_objects
    if len(selected) == 0:
        if report == True:
            print(
                "utils::has_armature reports: no argument and no selection, nothing to do"
            )
        return False

    mesh = []
    arms = []
    for o in selected:
        if o.type == "MESH":
            mesh.append(o)
        elif o.type == "ARMATURE":
            arms.append(o)

    if len(mesh) == 0 and len(arms) > 1:
        if report == True:
            print(
                "utils::has_armature reports : no mesh selected and too many armatures, expected 1 armature or 1 or more mesh and/or armature with it"
            )
        return False

    if len(mesh) == 0 and len(arms) == 1:

        if report == True:
            print(
                "utils::has_armature reports : Found armature on the single selected armature:",
                arms[0].name,
            )
        return arms[0]

    if len(mesh) == 0:
        if report == True:
            print(
                "utils::has_armature reports : after running excessive tests on the selected objects no qualified mesh or armatures were found"
            )
        return False

    mods = set()
    objs = set()
    for o in mesh:
        mesh_mods = []
        for m in o.modifiers:
            if m.type == "ARMATURE":
                mesh_mods.append(m)
        if len(mesh_mods) == 0:
            if report == True:
                print("No qualified modifiers on", o.name)
        else:
            if report == True:
                print("Found qualified modifiers on", o.name)
            if len(mesh_mods) > 1:
                if report == True:
                    print("Too many armature modifiers on", o.name)
            else:
                if mesh_mods[0].object == None:
                    if report == True:
                        print("Modifier points to nothing", o.name)
                else:
                    if is_valid(mesh_mods[0].object):
                        if report == True:
                            print("found valid armature modifier on", o.name)
                        objs.add(mesh_mods[0].object)

    if len(objs) > 1:
        if report == True:
            print(
                "utils::has_armature reports : too many directions, the target objects for qualified mesh with qualified armatures is greater than 1"
            )
        return False
    if len(objs) == 0:
        if report == True:
            print(
                "utils::has_armature reports : no qualified armatures armatures were found on the selected mesh"
            )
        return False

    return list(objs)[0]


def get_properties(group=None):
    props = {}
    for k in group.__annotations__.keys():
        v = getattr(group, k)
        props[k] = v
    return props


get_props = get_properties


def set_properties(group=None, props=None):
    for k in props:
        v = props[k]
        setattr(group, k, v)
    return True


set_props = set_properties


def duplicate(objects=None):
    """Duplicate objects using ops without them being selected and make a safe (active)
    choice then return an expected result, False or only those objects that were
    duplicated are selected"""

    if objects == None:
        sources = bpy.context.selected_objects
    else:
        if isinstance(objects, str):
            sources = [bpy.data.objects[objects]]
        elif isinstance(objects, list):
            sources = objects
        else:

            sources = [objects]

    if len(sources) == 0:
        print("utils::copy reports : No objects to process")
        return False

    if bpy.context.active_object not in sources:
        activate(sources[0])
    active = bpy.context.active_object
    for o in bpy.context.selected_objects:
        o.select_set(False)
    for o in sources:
        o.select_set(True)
    bpy.ops.object.duplicate()
    return bpy.context.selected_objects


def update():
    bpy.context.view_layer.update()


def compose_bone_transforms(
    inBone=None, outBone=None, location=False, rotation=False, scale=False, apply=False
):
    if location == False and rotation == False and scale == False:
        print("utils::compose_bone_transforms reports : no directive")
        return False
    if inBone == None:
        print("utils::compose_bone_transforms reports : no input")
        return False
    if outBone == None:
        print("utils::compose_bone_transforms reports : no output")
        return False

    in_location, in_rotation, in_scale = inBone.matrix_local.decompose()
    out_location, out_rotation, out_scale = outBone.matrix_local.decompose()
    if location == True:
        out_location = in_location
    if rotation == True:
        out_rotation = in_rotation
    if scale == True:
        out_scale = in_scale
    L = mathutils.Matrix.Translation(out_location)
    R = out_rotation.to_matrix().to_4x4()
    S = mathutils.Matrix()
    for i in range(3):
        S[i][i] = out_scale[i]

    M = L @ R @ S

    if apply == True:
        outBone.matrix = M

    return M


def compose_transforms(
    matrix_in=None, matrix_out=None, location=False, rotation=False, scale=False
):
    if location == False and rotation == False and scale == False:
        print("utils::compose_transforms reports : no directive")
        return False
    if matrix_in == None:
        print("utils::compose_transforms reports : no input")
        return False
    if matrix_out == None:
        print("utils::compose_transforms reports : no output")
        return False

    in_location, in_rotation, in_scale = matrix_in.decompose()
    out_location, out_rotation, out_scale = matrix_out.decompose()
    if location == True:
        out_location = in_location
    if rotation == True:
        out_rotation = in_rotation
    if scale == True:
        out_scale = in_scale
    L = mathutils.Matrix.Translation(out_location)
    R = out_rotation.to_matrix().to_4x4()
    S = mathutils.Matrix()
    for i in range(3):
        S[i][i] = out_scale[i]

    M = L @ R @ S

    return M


def vec_roll_to_mat3(vec, roll):
    nor = vec.normalized()
    THETA_THRESHOLD_NEGY = 1.0e-9
    THETA_THRESHOLD_NEGY_CLOSE = 1.0e-5

    bMatrix = mathutils.Matrix().to_3x3()

    theta = 1.0 + nor[1]

    if (theta > THETA_THRESHOLD_NEGY_CLOSE) or (
        (nor[0] or nor[2]) and theta > THETA_THRESHOLD_NEGY
    ):

        bMatrix[1][0] = -nor[0]
        bMatrix[0][1] = nor[0]
        bMatrix[1][1] = nor[1]
        bMatrix[2][1] = nor[2]
        bMatrix[1][2] = -nor[2]
        if theta > THETA_THRESHOLD_NEGY_CLOSE:

            bMatrix[0][0] = 1 - nor[0] * nor[0] / theta
            bMatrix[2][2] = 1 - nor[2] * nor[2] / theta
            bMatrix[0][2] = bMatrix[2][0] = -nor[0] * nor[2] / theta

        else:

            theta = nor[0] * nor[0] + nor[2] * nor[2]
            bMatrix[0][0] = (nor[0] + nor[2]) * (nor[0] - nor[2]) / -theta
            bMatrix[2][2] = -bMatrix[0][0]
            bMatrix[0][2] = bMatrix[2][0] = 2.0 * nor[0] * nor[2] / theta

    else:

        bMatrix = mathutils.Matrix().to_3x3()
        bMatrix[0][0] = bMatrix[1][1] = -1.0

    rMatrix = mathutils.Matrix.Rotation(roll, 3, nor)

    mat = rMatrix @ bMatrix
    return mat


def mat3_to_vec_roll(mat):

    vec = mat.col[1]
    vecmat = vec_roll_to_mat3(mat.col[1], 0)
    vecmatinv = vecmat.inverted()
    rollmat = vecmatinv @ mat
    roll = math.atan2(rollmat[0][2], rollmat[2][2])
    return vec, roll


def get_bone_roll(mat):
    v, r = mat3_to_vec_roll(mat.to_3x3())
    return r


def make_single(obj):
    if isinstance(obj, str):
        OBJ = bpy.data.objects[obj]
    else:
        OBJ = obj

    state = get_state()
    OBJ.select_set(True)
    activate(OBJ)

    bpy.ops.object.mode_set(mode="OBJECT")

    bpy.ops.object.make_single_user(
        object=True, obdata=True, material=False, animation=False
    )
    set_state(state)
    return True


make_unique = make_single


def apply_transforms(object=None, rotation=True, location=True, scale=True):
    OBJ = object
    if isinstance(object, str):
        OBJ = bpy.data.objects[object]
    state = get_state()
    OBJ.select_set(True)
    activate(OBJ)
    bpy.ops.object.transform_apply(rotation=rotation, location=location, scale=scale)
    set_state(state)
    return True


def rotate_matrix(matrix=None, forward="X"):
    MBI = matrix.inverted()
    R90 = mathutils.Matrix.Rotation(math.radians(90.0), 4, "Z")
    R90I = R90.inverted()
    R180 = mathutils.Matrix.Rotation(math.radians(180.0), 4, "Z")
    R180I = R180.inverted()

    if forward == "-Y":
        M = MBI @ R90I
        M = R90I @ M @ R90I
        return M
    if forward == "X":

        M = R90I @ MBI
        M = M @ R180
        M = R90 @ M
        return M

    return False


def get_object_props(object=None, prop=None, scope="all", report=True):

    def get_single_property(object, prop):

        fail = True
        try:
            p = object[prop].to_dict()
            return p
        except:
            pass
        try:
            p = object[prop].to_list()
            return p
        except:
            pass
        try:
            p = object[prop]
            if isinstance(p, str):
                return p
            elif isinstance(p, float):
                return p
            elif isinstance(p, int):
                return p
            elif isinstance(p, list):
                return p
        except:

            p = object[prop]
            return object[prop][p]

        if fail == True:
            print(
                "Could not return the type of property targeted by",
                prop,
                "in object",
                object.name,
            )
            return False

        return p

    OBJ = object
    if isinstance(OBJ, str):
        OBJ = bpy.data.objects[object]

    if scope == "all":
        props = {}
        props["object"] = {}
        for p in OBJ.keys():
            result = get_single_property(OBJ, p)
            if result != False:
                props["object"][p] = result
        if OBJ.type == "ARMATURE":
            armObj = OBJ
            state = get_state()
            armObj.select_set(True)
            activate(armObj)
            props["bones"] = {}
            props["bones"]["pose"] = {}
            props["bones"]["data"] = {}
            props["bones"]["edit"] = {}
            bpy.ops.object.mode_set(mode="EDIT")
            for pose_boneObj in armObj.pose.bones:
                bone = pose_boneObj.name
                data_boneObj = pose_boneObj.bone
                edit_boneObj = armObj.data.edit_bones[bone]
                for p in pose_boneObj.keys():
                    result = get_single_property(pose_boneObj, p)
                    if result != False:
                        props["bones"]["pose"][p] = result
                for p in data_boneObj.keys():
                    result = get_single_property(data_boneObj, p)
                    if result != False:
                        props["bones"]["data"][p] = result
                for p in edit_boneObj.keys():
                    result = get_single_property(edit_boneObj, p)
                    if result != False:
                        props["bones"]["edit"][p] = result
            set_state(state)

        return props

    if prop == None:
        print("utils:get_prop : no property to extract")
        return False


def get_difference(base=0, offset=0):
    a = base
    b = offset
    if a == b:
        return 0
    elif (a < 0) and (b < 0) or (a > 0) and (b > 0):
        if a < b:
            return abs(abs(a) - abs(b))
        else:
            return -(abs(abs(a) - abs(b)))
    else:
        return math.copysign((abs(a) + abs(b)), b)


def get_percent(base=0, offset=0):
    a = base
    b = offset
    diff = abs(a - b)
    if diff == 0:
        return 0
    div = a / diff
    percent = 100 / div
    return percent


def get_scale(base=0, offset=0):
    scale = (float(offset) - base) / base
    return scale


def to_deg(mat):
    eu = mat.to_euler()
    return [math.degrees(round(a, 4)) for a in eu]


def get_stored_scale(boneObj, S=None, truly_weird=True):

    s0 = mathutils.Vector(boneObj.get("scale0", (1, 1, 1)))

    if truly_weird:

        x = boneObj.get("restpose_scale_y", s0[0])
        y = boneObj.get("restpose_scale_x", s0[1])
        z = boneObj.get("restpose_scale_z", s0[2])
        sc = mathutils.Vector((x, y, z))

        sc0m = abs(sc.magnitude - s0.magnitude)
        sc0n = abs(sc.normalized().dot(s0.normalized()) - 1)
        if sc0m > 0.0001 and sc0n > 0.0001:
            s0 = sc

    ds = mathutils.Vector(boneObj.get("scale", (0, 0, 0)))

    s_ = s0 + ds

    s = s_.copy()
    s[0] = s_[1]
    s[1] = s_[0]
    if S == None:
        S = mathutils.Matrix()
    for i in range(3):
        if s[i] == 0:
            s[i] = 0.000001
        S[i][i] *= s[i]

    return S


def select(object, state):
    Obj = object
    if isinstance(object, str):
        Obj = bpy.data.objects[object]
    Obj.select = state


def set_inverse(context_py, cname):

    if bpy.app.version < (2, 90, 0):
        bpy.ops.constraint.childof_set_inverse(
            context_py, constraint=cname, owner="BONE"
        )
    else:
        bpy.ops.constraint.childof_set_inverse(constraint=cname, owner="BONE")

    return True


def vertex_constraint(
    arm=None,
    bone=None,
    mesh=None,
    vertices=[],
    influence=1,
    location=True,
    rotation=True,
    scale=False,
):
    armObj = arm
    boneObj = bone
    meshObj = mesh
    if isinstance(arm, str):
        armObj = bpy.data.objects[arm]
    if isinstance(bone, str):
        boneObj = armObj.pose.bones[bone]
    if isinstance(mesh, str):
        meshObj = bpy.data.objects[mesh]
    if len(vertices) == 0:
        print("utils::vertex_constraint : No vertices were delivered, nothing to do ")
        return False

    G = meshObj.vertex_groups.new(name=boneObj.name)
    G.add(vertices, 1, "REPLACE")

    armObj.data.bones.active = boneObj.bone
    bc = boneObj.constraints

    conObj = bc.new("CHILD_OF")
    cname = conObj.name
    conObj.target = meshObj
    conObj.subtarget = boneObj.name
    conObj.influence = influence
    conObj.use_location_x = location
    conObj.use_location_y = location
    conObj.use_location_z = location
    conObj.use_rotation_x = rotation
    conObj.use_rotation_y = rotation
    conObj.use_rotation_z = rotation
    conObj.use_scale_x = scale
    conObj.use_scale_y = scale
    conObj.use_scale_z = scale

    context_py = bpy.context.copy()
    context_py["constraint"] = bc.active

    if 1 == 0:
        new_state = utils.get_state()
        aObj.select_set(True)
        utils.activate(aObj)
        bpy.ops.object.mode_set(mode="POSE")

    set_inverse(context_py, cname)

    conObj.name = "ONI Sim " + cname

    if props["constraint_group_base"] not in armObj.pose.bone_groups:
        bpy.ops.pose.group_add()
    armObj.pose.bone_groups.active.name = props["constraint_group_base"]
    armObj.pose.bone_groups.active.color_set = props["constraint_theme_base"]
    group_base = sim.props["constraint_group_base"]
    boneObj.bone_group = armObj.pose.bone_groups[group_base]

    return True


def rig_is_selected():
    if len(bpy.context.selected_objects) == 1:
        if bpy.context.selected_objects[0].type == "ARMATURE":
            return bpy.context.selected_objects[0]
    return False


def is_visible(OBJ):
    pass


def base_to_sign(base=0, offset=0):

    difference = abs(base - offset)
    final = difference
    if offset < base:
        final = difference - (difference * 2)

    return final


def normalize_float(f, max=6):
    reduced = round(f, max)
    result = abs(reduced)
    if result <= 10**-max:
        result = reduced
    return result


def make_filenames(prefix="Anim", count=None, ext=".anim"):
    if count == 0:
        print("utils::make_filenames : no count specified")
        return False
    if count > 999:
        print("Can't exceed 999 items")
        return False

    n = 0
    file_names = []
    for a in range(count):

        n += 1
        ns = str(n)
        zf = ns.zfill(3)
        anim_name = prefix + "_" + zf + ext
        file_names.append(anim_name)

    return file_names
